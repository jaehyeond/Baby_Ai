{
  "short_term": [
    {
      "id": "6fef2f13de4d",
      "request": "병합정렬 알고리즘 구현해줘",
      "action": "def merge_sort(arr):\n    \"\"\"병합 정렬 알고리즘 구현\"\"\"\n    # 기저 조건: 배열의 길이가 1 이하면 정렬된 것으로 간주\n    if len(arr) <= 1:\n        return arr\n    \n    # 배열을 중간점을 기준으로 두 부분으로 나눔\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # 재귀적으로 왼쪽과 오른쪽 부분을 정렬\n    left_sorted = merge_sort(left)\n    right_sorted = merge_sort(right)\n    \n    # 정렬된 두 부분을 병합\n    return merge(left_sorted, right_sorted)\n\ndef merge(left, right):\n    \"\"\"두 개의 정렬된 배열을 병합하는 함수\"\"\"\n    result = []\n    i = j = 0\n    \n    # 두 배열을",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2025-12-31T14:21:06.660853"
    },
    {
      "id": "a15f2fbe66f2",
      "request": "버블정렬 알고리즘 구현해줘",
      "action": "```python\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n```",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:15:49.283854"
    },
    {
      "id": "9a718146ae70",
      "request": "이 코드가 뭘 하는지 설명해줘: def fib(n): return n if n < 2 else fib(n-1) + fib(n-2)",
      "action": "```python\ndef fib(n):\n    return n if n < 2 else fib(n-1) + fib(n-2)\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:17:45.460825"
    },
    {
      "id": "9a8d8bad8cdc",
      "request": "이 코드의 버그를 찾아서 수정해줘: def factorial(n): if n == 0: return 1 return n * factorial(n)",
      "action": "```python\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:19:31.581663"
    },
    {
      "id": "9c025138a9e8",
      "request": "퀵소트 알고리즘 구현해줘",
      "action": "```python\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n\n# 예시 사용\narr = [3, 6, 8, 10, 1, 2, 1]\nsorted_arr = quicksort(arr)\nprint(sorted_arr)\n```",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:21:20.060027"
    },
    {
      "id": "5e454f440746",
      "request": "이진검색 알고리즘 구현해줘",
      "action": "```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return -1\n```",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:22:48.106669"
    },
    {
      "id": "5607a5520713",
      "request": "힙소트 알고리즘 구현해줘",
      "action": "```python\ndef heapsort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for ",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:25:56.266756"
    },
    {
      "id": "6f83674f97ab",
      "request": "두 숫자의 최대공약수를 구하는 함수 만들어줘",
      "action": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return abs(a)\n\n# 테스트 케이스 실행\nprint(gcd(12, 18))    # 6\nprint(gcd(7, 3))      # 1  \nprint(gcd(-12, 8))    # 4\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:27:37.485308"
    },
    {
      "id": "210303874781",
      "request": "문자열을 뒤집는 함수 만들어줘",
      "action": "```python\ndef reverse_string(s):\n    return s[::-1]\n\n# 테스트 케이스\nprint(reverse_string(\"hello\"))  # \"olleh\"\nprint(reverse_string(\"Python\"))  # \"nohtyP\"\nprint(reverse_string(\"12345\"))   # \"54321\"\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:30:27.598275"
    },
    {
      "id": "9037b29545cb",
      "request": "Person 클래스를 만들어줘. 이름과 나이 속성이 있고 인사하는 메서드가 있어야해",
      "action": "```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greet(self):\n        return f\"안녕하세요, 제 이름은 {self.name}이고, 나이는 {self.age}세입니다.\"\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:33:17.019668"
    },
    {
      "id": "3c805812d152",
      "request": "리스트에서 중복을 제거하는 함수 만들어줘",
      "action": "```python\ndef remove_duplicates(lst):\n    seen = set()\n    unique_lst = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            unique_lst.append(item)\n    return unique_lst\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:35:45.181238"
    },
    {
      "id": "c3312f08ff0c",
      "request": "삽입정렬 알고리즘 구현해줘",
      "action": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:37:39.882810"
    },
    {
      "id": "39e77cdd2f92",
      "request": "스택 자료구조를 클래스로 구현해줘",
      "action": "```python\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        \"\"\"스택의 최상단에 요소를 추가합니다.\"\"\"\n        self.items.append(item)\n\n    def pop(self):\n        \"\"\"스택의 최상단 요소를 제거하고 반환합니다. 스택이 비어있으면 None을 반환합니다.\"\"\"\n        if not self.is_empty():\n            return self.items.pop()\n        return None\n\n    def peek(self):\n        \"\"\"스택의 최상단 요소를 반환합니다. 스택이 비어있으면 None을 반환합니다.\"\"\"\n        if not self.is_empty():\n            return self.items[-1]\n        return None\n\n   ",
      "outcome": "success",
      "success": true,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:39:06.428120"
    },
    {
      "id": "997e520d2664",
      "request": "소수인지 판별하는 함수 만들어줘",
      "action": "```python\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:39:49.672340"
    },
    {
      "id": "60af6c8a6bff",
      "request": "큐 자료구조를 클래스로 구현해줘",
      "action": "```python\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def dequeue(self):\n        if not self.is_empty():\n            return self.items.pop(0)\n        raise IndexError(\"dequeue from an empty queue\")\n\n    def peek(self):\n        if not self.is_empty():\n            return self.items[0]\n        raise IndexError(\"peek from an empty queue\")\n\n    def size(self",
      "outcome": "success",
      "success": true,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:40:34.488716"
    },
    {
      "id": "8c9af99265b9",
      "request": "선택정렬 알고리즘 구현해줘",
      "action": "```python\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_index = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n```",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:41:18.094809"
    },
    {
      "id": "44e94389cacf",
      "request": "팩토리얼 계산 함수 만들어줘",
      "action": "```python\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Negative values are not allowed.\")\n    elif n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:42:59.514699"
    },
    {
      "id": "a568e1c9d9a0",
      "request": "연결리스트 노드 클래스 구현해줘",
      "action": "```python\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:44:33.705997"
    },
    {
      "id": "07ca01105414",
      "request": "DFS 깊이우선탐색 알고리즘 구현해줘",
      "action": "```python\ndef dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    \n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n    \n    return visited\n\n# 예시 그래프\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\n# DFS 실행\nvisited_nodes = dfs(graph, 'A')\nprint(visited_nodes)\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:46:41.824972"
    },
    {
      "id": "9802a40c5284",
      "request": "BFS 너비우선탐색 알고리즘 구현해줘",
      "action": "```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = []\n    queue = deque([start])\n\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            visited.append(node)\n            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\n    \n    return visited\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:49:36.714335"
    },
    {
      "id": "d3ca3470d92b",
      "request": "카운팅정렬 알고리즘 구현해줘",
      "action": "```python\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    range_of_elements = max_val - min_val + 1\n    \n    count = [0] * range_of_elements\n    output = [0] * len(arr)\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    \n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n    \n    return o",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:50:32.162023"
    },
    {
      "id": "869b710a81fd",
      "request": "이진트리 노드 클래스 구현해줘",
      "action": "```python\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
      "outcome": "success",
      "success": true,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:51:10.144574"
    },
    {
      "id": "5d4850dff9f6",
      "request": "두 리스트의 교집합을 구하는 함수 만들어줘",
      "action": "```python\ndef intersection(list1, list2):\n    return list(set(list1) & set(list2))\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:51:51.084446"
    },
    {
      "id": "4fa39879eaf2",
      "request": "문자열이 회문인지 확인하는 함수 만들어줘",
      "action": "```python\ndef is_palindrome(s):\n    # 알파벳과 숫자만 추출하고 소문자로 변환\n    filtered_str = ''.join(char.lower() for char in s if char.isalnum())\n    # 원본 문자열과 뒤집은 문자열 비교\n    return filtered_str == filtered_str[::-1]\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:53:29.825952"
    },
    {
      "id": "a40b066f7e6d",
      "request": "해시맵 클래스 구현해줘",
      "action": "```python\nclass HashMap:\n    def __init__(self, size=16):\n        self.size = size\n        self.map = [[] for _ in range(size)]\n\n    def _hash(self, key):\n        return hash(key) % self.size\n\n    def set(self, key, value):\n        index = self._hash(key)\n        for pair in self.map[index]:\n            if pair[0] == key:\n                pair[1] = value\n                return\n        self.map[index].append([key, value])\n\n    def get(self, key):\n        index = self._hash(key)\n        for pair in",
      "outcome": "failure",
      "success": false,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:55:49.242125"
    },
    {
      "id": "f6e5fda85c2a",
      "request": "기수정렬 알고리즘 구현해줘",
      "action": "```python\ndef counting_sort(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n\n    for i in range(n):\n        index = arr[i] // exp\n        count[index % 10] += 1\n\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n\n    for i in range(n - 1, -1, -1):\n        index = arr[i] // exp\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n\n    for i in range(n):\n        arr[i] = output[i]\n\ndef radix_sort(arr):\n    max1 = max(arr)\n    exp = 1\n    whi",
      "outcome": "failure",
      "success": false,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T20:58:15.097862"
    },
    {
      "id": "84fd62bc4ee1",
      "request": "배열에서 최대값과 최소값을 동시에 찾는 함수 만들어줘",
      "action": "def find_max_min(arr):\n    if not arr:\n        return None, None\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val, min_val",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T20:59:32.163080"
    },
    {
      "id": "8b1d9ca19f0c",
      "request": "우선순위 큐 클래스 구현해줘",
      "action": "```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.elements = []\n\n    def is_empty(self):\n        return not self.elements\n\n    def put(self, item, priority):\n        heapq.heappush(self.elements, (priority, item))\n\n    def get(self):\n        return heapq.heappop(self.elements)[1]\n\n    def peek(self):\n        return self.elements[0][1] if self.elements else None\n\n    def size(self):\n        return len(self.elements)\n\n# Example usage\nif __name__ == \"__main__\":\n    p",
      "outcome": "success",
      "success": true,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:00:20.994361"
    },
    {
      "id": "9218d45d5208",
      "request": "셸정렬 알고리즘 구현해줘",
      "action": "```python\ndef shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr\n\n# 예시 사용\narr = [12, 34, 54, 2, 3]\nsorted_arr = shell_sort(arr)\nprint(sorted_arr)  # 출력: [2, 3, 12, 34, 54]\n```",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:01:13.635879"
    },
    {
      "id": "c2c01de8a9a4",
      "request": "팀소트 알고리즘 구현해줘",
      "action": "```python\ndef insertion_sort(arr, left, right):\n    for i in range(left + 1, right + 1):\n        key_item = arr[i]\n        j = i - 1\n        while j >= left and arr[j] > key_item:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key_item\n\ndef merge(arr, left, mid, right):\n    left_copy = arr[left:mid + 1]\n    right_copy = arr[mid + 1:right + 1]\n    \n    left_index, right_index = 0, 0\n    sorted_index = left\n    \n    while left_index < len(left_copy) and right_index < len(r",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:04:31.451708"
    },
    {
      "id": "0a173bb360d5",
      "request": "DFS 깊이우선탐색 알고리즘 구현해줘. 재귀 방식으로.",
      "action": "",
      "outcome": "failure",
      "success": false,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:13:19.079537"
    },
    {
      "id": "b7f9ac483684",
      "request": "DFS 깊이우선탐색 알고리즘 구현해줘. 재귀 방식으로.",
      "action": "```python\ndef dfs(graph, node, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(node)\n    print(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n    return visited\n\n# 예시 그래프\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\n# DFS 호출\ndfs(graph, 'A')\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:16:03.925542"
    },
    {
      "id": "9ac54038f452",
      "request": "BFS 너비우선탐색 알고리즘 구현해줘. deque 사용해서.",
      "action": "```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    result = []\n\n    while queue:\n        vertex = queue.popleft()\n        if vertex not in visited:\n            visited.add(vertex)\n            result.append(vertex)\n            queue.extend(neighbor for neighbor in graph[vertex] if neighbor not in visited)\n    \n    return result\n\n# 예제 그래프\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n   ",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:16:55.619197"
    },
    {
      "id": "a4199b82a4ea",
      "request": "해시맵 클래스 구현해줘. get, set, delete 메서드 포함.",
      "action": "```python\nclass HashMap:\n    def __init__(self):\n        self.size = 10\n        self.map = [[] for _ in range(self.size)]\n\n    def _hash(self, key):\n        return hash(key) % self.size\n\n    def set(self, key, value):\n        index = self._hash(key)\n        for pair in self.map[index]:\n            if pair[0] == key:\n                pair[1] = value\n                return\n        self.map[index].append([key, value])\n\n    def get(self, key):\n        index = self._hash(key)\n        for pair in self.",
      "outcome": "success",
      "success": true,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:17:57.188323"
    },
    {
      "id": "4a9fe952bd7e",
      "request": "Stack 클래스를 만들고, 이를 사용해서 괄호 균형을 검사하는 함수도 만들어줘",
      "action": "```python\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n        raise IndexError(\"pop from empty stack\")\n\n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n        raise IndexError(\"peek from empty stack\")\n\n    def is_empty(self):\n        return len(self.items) == 0\n\ndef is_balanced(expression):\n    s",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:20:07.740177"
    },
    {
      "id": "aebac4b3cf34",
      "request": "이진탐색 함수와 이를 테스트하는 테스트 케이스를 함께 만들어줘",
      "action": "```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return -1\n\n# Test cases\ndef test_binary_search():\n    assert binary_search([1, 2, 3, 4, 5], 3) == 2\n    assert binary_search([1, 2, 3, 4, 5], 1) == 0\n    assert binary_sear",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:20:57.605659"
    },
    {
      "id": "fc805bfcf867",
      "request": "다익스트라 최단경로 알고리즘 구현해줘",
      "action": "```python\nimport heapq\n\ndef dijkstra(graph, start):\n    # 최단 거리 초기화\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        # 현재 노드의 거리보다 더 긴 거리라면 무시\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + ",
      "outcome": "failure",
      "success": false,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:23:23.434787"
    },
    {
      "id": "67bd4a54134c",
      "request": "피보나치를 동적 프로그래밍으로 구현해줘. 메모이제이션 사용.",
      "action": "def fibonacci(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n < 2:\n        return n\n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]",
      "outcome": "failure",
      "success": false,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:25:12.410578"
    },
    {
      "id": "efbf69f75f41",
      "request": "문자열에서 모음 개수를 세는 함수 만들어줘",
      "action": "```python\ndef count_vowels(s):\n    vowels = 'aeiouAEIOU'\n    return sum(1 for char in s if char in vowels)\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:25:52.143395"
    },
    {
      "id": "a1e09229972c",
      "request": "두 정렬된 리스트를 병합하는 함수 만들어줘",
      "action": "def merge_sorted_lists(list1, list2):\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])\n            i += 1\n        else:\n            merged_list.append(list2[j])\n            j += 1\n\n    merged_list.extend(list1[i:])\n    merged_list.extend(list2[j:])\n    \n    return merged_list",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:27:45.450411"
    },
    {
      "id": "062ce19073bf",
      "request": "문자열을 단어 단위로 뒤집는 함수 만들어줘",
      "action": "```python\ndef reverse_words(s):\n    return ' '.join(s.split()[::-1])\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:28:28.590690"
    },
    {
      "id": "9c9494396515",
      "request": "배열에서 두 수의 합이 target이 되는 인덱스 찾는 함수 만들어줘",
      "action": "```python\ndef two_sum(nums, target):\n    num_to_index = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], index]\n        num_to_index[num] = index\n    return None\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:29:07.240296"
    },
    {
      "id": "a19ed0e1d73f",
      "request": "링크드리스트를 뒤집는 함수 구현해줘",
      "action": "```python\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list(head):\n    prev = None\n    current = head\n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    return prev\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:29:52.939587"
    },
    {
      "id": "fd9e3d4639d0",
      "request": "LRU 캐시 클래스 구현해줘",
      "action": "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        else:\n            self.order.remove(key)\n            self.order.append(key)\n            return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache[key] = value\n            self.order.rem",
      "outcome": "failure",
      "success": false,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:32:10.046299"
    },
    {
      "id": "e47834fef2a4",
      "request": "배열의 모든 순열을 구하는 함수 만들어줘",
      "action": "```python\nfrom itertools import permutations\n\ndef generate_permutations(arr):\n    return list(permutations(arr))\n\n# 예시 사용법\narr = [1, 2, 3]\nprint(generate_permutations(arr))\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:32:55.291064"
    },
    {
      "id": "4389e2f61b69",
      "request": "행렬 전치 함수 만들어줘",
      "action": "```python\ndef transpose(matrix):\n    return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:33:35.996159"
    },
    {
      "id": "739986c7cb3f",
      "request": "중복된 문자를 제거하고 첫 등장 순서 유지하는 함수 만들어줘",
      "action": "```python\ndef remove_duplicates(s):\n    seen = set()\n    result = []\n    for char in s:\n        if char not in seen:\n            seen.add(char)\n            result.append(char)\n    return ''.join(result)\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:35:17.849260"
    },
    {
      "id": "9d06eaf03a01",
      "request": "최대공약수 구하는 함수 만들어줘",
      "action": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:35:52.441666"
    },
    {
      "id": "b0b1034178d5",
      "request": "최소공배수 구하는 함수 만들어줘",
      "action": "```python\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\n# 예시 사용\nprint(lcm(4, 6))  # 12\nprint(lcm(15, 20))  # 60\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:36:30.648253"
    },
    {
      "id": "12a3d1523e78",
      "request": "문자열에서 가장 긴 공통 접두사 찾는 함수 만들어줘",
      "action": "```python\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    \n    prefix = strs[0]\n    for string in strs[1:]:\n        while string[:len(prefix)] != prefix and prefix:\n            prefix = prefix[:-1]\n    \n    return prefix\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:37:13.140286"
    },
    {
      "id": "68368d9685b1",
      "request": "문자열 압축 함수 만들어줘. aabcccccaaa를 a2b1c5a3으로",
      "action": "```python\ndef compress_string(s):\n    if not s:\n        return \"\"\n    \n    compressed = []\n    count = 1\n    \n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            compressed.append(s[i - 1] + str(count))\n            count = 1\n    \n    compressed.append(s[-1] + str(count))  # Add the last group\n    return ''.join(compressed)\n\n# Example usage:\nresult = compress_string(\"aabcccccaaa\")\nprint(result)  # Output: a2b1c5a3\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:37:59.021619"
    },
    {
      "id": "72621dcf2abb",
      "request": "배열을 k칸 회전하는 함수 만들어줘",
      "action": "```python\ndef rotate_array(arr, k):\n    n = len(arr)\n    k = k % n  # Handle cases where k is greater than n\n    return arr[-k:] + arr[:-k]\n\n# Example usage:\n# rotated_array = rotate_array([1, 2, 3, 4, 5], 2)\n# print(rotated_array)  # Output: [4, 5, 1, 2, 3]\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:38:43.426962"
    },
    {
      "id": "608d0750c3bb",
      "request": "단일 연결리스트에서 사이클 존재 여부 확인하는 함수 만들어줘",
      "action": "```python\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef has_cycle(head):\n    slow = head\n    fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:39:28.200759"
    },
    {
      "id": "0aa7bc4bd084",
      "request": "이진트리 중위순회 함수 만들어줘",
      "action": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef inorder_traversal(root):\n    if root is None:\n        return []\n    return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right)",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:41:22.169585"
    },
    {
      "id": "635cdd6112c3",
      "request": "이진트리 최대 깊이 구하는 함수 만들어줘",
      "action": "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_depth(root):\n    if not root:\n        return 0\n    else:\n        left_depth = max_depth(root.left)\n        right_depth = max_depth(root.right)\n        return max(left_depth, right_depth) + 1\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:43:13.581487"
    },
    {
      "id": "a297289ec4cf",
      "request": "배열에서 과반수 요소 찾는 함수 만들어줘",
      "action": "```python\ndef majority_element(arr):\n    count = 0\n    candidate = None\n    \n    for num in arr:\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n    \n    return candidate if arr.count(candidate) > len(arr) // 2 else None\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:43:53.152523"
    },
    {
      "id": "95065b116a69",
      "request": "유효한 괄호 문자열인지 확인하는 함수 만들어줘",
      "action": "```python\ndef is_valid_parentheses(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if stack == [] or mapping[char] != stack.pop():\n                return False\n    \n    return stack == []\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:45:09.145184"
    },
    {
      "id": "b42afd6c441e",
      "request": "문자열에서 가장 긴 부분 문자열 찾는 함수 만들어줘",
      "action": "```python\ndef longest_unique_substring(s):\n    char_index = {}\n    longest = 0\n    start = 0\n\n    for i, char in enumerate(s):\n        if char in char_index and char_index[char] >= start:\n            start = char_index[char] + 1\n        char_index[char] = i\n        longest = max(longest, i - start + 1)\n\n    return longest\n\n# 예시 사용\nprint(longest_unique_substring(\"abcabcbb\"))  # 출력: 3\nprint(longest_unique_substring(\"bbbbb\"))     # 출력: 1\nprint(longest_unique_substring(\"pwwkew\"))    # 출력: 3\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:46:31.140601"
    },
    {
      "id": "3c509d0afffa",
      "request": "숫자 배열에서 연속된 숫자의 최대 길이 구하는 함수",
      "action": "```python\ndef max_consecutive_length(arr):\n    if not arr:\n        return 0\n    \n    arr = sorted(set(arr))\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i - 1] + 1:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n\n    return max(max_length, current_length)\n\n# Example usage:\n# print(max_consecutive_length([100, 4, 200, 1, 3, 2]))  # Output: 4\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:47:20.168302"
    },
    {
      "id": "a0eda53162b8",
      "request": "정수 배열에서 0인 원소를 배열 끝으로 이동시키는 함수",
      "action": "```python\ndef move_zeros(arr):\n    non_zeroes = [x for x in arr if x != 0]\n    zeroes = [0] * (len(arr) - len(non_zeroes))\n    return non_zeroes + zeroes\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:48:40.562496"
    },
    {
      "id": "7895832f474f",
      "request": "문자열이 아나그램인지 확인하는 함수",
      "action": "```python\ndef are_anagrams(str1, str2):\n    return sorted(str1) == sorted(str2)\n\n# 테스트\nprint(are_anagrams(\"listen\", \"silent\"))  # True\nprint(are_anagrams(\"triangle\", \"integral\"))  # True\nprint(are_anagrams(\"apple\", \"pale\"))  # False\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:49:59.962802"
    },
    {
      "id": "3f3219aee03e",
      "request": "배열에서 k번째로 큰 요소 찾는 함수",
      "action": "```python\ndef kth_largest(arr, k):\n    if k <= 0 or k > len(arr):\n        return None\n    sorted_arr = sorted(arr, reverse=True)\n    return sorted_arr[k - 1]\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:51:20.888617"
    },
    {
      "id": "c767bcb121db",
      "request": "정수를 로마 숫자로 변환하는 함수",
      "action": "```python\ndef int_to_roman(num):\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    roman_num = ''\n    i = 0\n    while num > 0:\n        for _ in range(num // val[i]):\n            roman_num += syms[i]\n            num -= val[i]\n        i += 1\n    return roman_num\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:52:08.576208"
    },
    {
      "id": "be69e4ee4e65",
      "request": "로마 숫자를 정수로 변환하는 함수",
      "action": "```python\ndef roman_to_integer(s: str) -> int:\n    roman_numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    \n    total = 0\n    prev_value = 0\n    \n    for char in reversed(s):\n        value = roman_numerals[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    \n    return total\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:54:08.812258"
    },
    {
      "id": "94f11549405a",
      "request": "배열에서 연속 부분 배열의 최대 합 구하는 함수",
      "action": "```python\ndef max_subarray_sum(arr):\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:54:54.884341"
    },
    {
      "id": "e02b09090129",
      "request": "숫자 리스트를 문자열로 연결해서 가장 큰 수 만드는 함수",
      "action": "```python\nfrom functools import cmp_to_key\n\ndef largest_number(nums):\n    if not nums:\n        return \"\"\n    \n    # Custom comparator\n    def compare(x, y):\n        return (y + x) > (x + y)\n\n    # Sort numbers based on the custom comparator\n    sorted_nums = sorted(map(str, nums), key=cmp_to_key(compare))\n    \n    # Join sorted numbers\n    largest_num = ''.join(sorted_nums)\n    \n    # Handle case where leading number is '0'\n    return largest_num if largest_num[0] != '0' else '0'\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:55:39.707670"
    },
    {
      "id": "4dc3ebd3f71c",
      "request": "배열을 나선형으로 출력하는 함수",
      "action": "```python\ndef spiral_order(matrix):\n    result = []\n    if not matrix:\n        return result\n\n    top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n        ",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-19T21:57:52.622509"
    },
    {
      "id": "137990a08863",
      "request": "배열에서 누적합 구하는 함수",
      "action": "```python\ndef cumulative_sum(arr):\n    result = []\n    total = 0\n    for num in arr:\n        total += num\n        result.append(total)\n    return result\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-19T21:58:35.087198"
    },
    {
      "id": "fda8b218635a",
      "request": "DFS 테스트",
      "action": "```python\ndef dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n    return visited\n\n# 예제 그래프\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\n# DFS 호출\nvisited_nodes = dfs(graph, 'A')\nprint(visited_nodes)\n```",
      "outcome": "success",
      "success": true,
      "task_type": "test",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:01:26.693404"
    },
    {
      "id": "3d285f2a65b3",
      "request": "다익스트라 최단경로 알고리즘 구현해줘. heapq 사용.",
      "action": "```python\nimport heapq\n\ndef dijkstra(graph, start):\n    # 최단 거리 테이블 초기화\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]  # (거리, 노드)\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        # 현재 노드까지의 거리가 이미 저장된 거리보다 크면 무시\n        if current_distance > distances[current_node]:\n            continue\n\n        # 인접 노드와의 거리 계산\n        for neighbor, weight in graph[current_node].items():\n",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:03:19.537069"
    },
    {
      "id": "fd60584816da",
      "request": "LRU Cache 클래스 구현해줘. OrderedDict 사용해서 get, put 메서드 포함.",
      "action": "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        else:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = va",
      "outcome": "success",
      "success": true,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:04:10.558557"
    },
    {
      "id": "f88eacdc9cd3",
      "request": "Trie(트라이) 자료구조 구현해줘. insert, search, startsWith 메서드 포함.",
      "action": "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self",
      "outcome": "success",
      "success": true,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:06:05.170511"
    },
    {
      "id": "ac27d55b239a",
      "request": "나선형 행렬 출력 함수 구현해줘. 2D 배열을 시계방향으로 나선형으로 출력.",
      "action": "```python\ndef spiral_matrix(matrix):\n    result = []\n    if not matrix:\n        return result\n\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n   ",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:07:44.430186"
    },
    {
      "id": "b0ec01a579ef",
      "request": "로마숫자를 정수로 변환하는 함수 구현해줘. IV=4, IX=9 등 뺄셈 규칙 포함.",
      "action": "```python\ndef roman_to_integer(s: str) -> int:\n    roman_map = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    \n    total = 0\n    prev_value = 0\n    \n    for char in reversed(s):\n        current_value = roman_map.get(char, 0)\n        if current_value < prev_value:\n            total -= current_value\n        else:\n            total += current_value\n        prev_value = current_value\n    \n    return total\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:09:52.325555"
    },
    {
      "id": "f726a6f85cfd",
      "request": "피보나치 수열을 DP로 구현해줘. Bottom-up 방식으로.",
      "action": "```python\ndef fibonacci(n):\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-20T00:11:49.731718"
    },
    {
      "id": "77beaec55c16",
      "request": "이진트리 최대 깊이 구하는 함수 만들어줘. 재귀로 구현.",
      "action": "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_depth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = max_depth(root.left)\n        right_depth = max_depth(root.right)\n        return max(left_depth, right_depth) + 1\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:12:33.986483"
    },
    {
      "id": "7d1be6335ce5",
      "request": "이진탐색트리(BST)에서 노드 삽입하는 함수 구현해줘.",
      "action": "```python\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef insert(root, key):\n    if root is None:\n        return TreeNode(key)\n    else:\n        if root.val < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n    return root\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:13:34.343976"
    },
    {
      "id": "ec19be5cf930",
      "request": "그래프에서 사이클 검출하는 함수 구현해줘. 방향 그래프에서.",
      "action": "```python\ndef has_cycle(graph):\n    visited = set()\n    visiting = set()\n\n    def dfs(node):\n        if node in visiting:\n            return True\n        if node in visited:\n            return False\n        \n        visiting.add(node)\n        for neighbor in graph.get(node, []):\n            if dfs(neighbor):\n                return True\n        visiting.remove(node)\n        visited.add(node)\n        return False\n\n    for vertex in graph:\n        if dfs(vertex):\n            return True\n    return ",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:15:17.114542"
    },
    {
      "id": "17164e813c09",
      "request": "위상정렬(Topological Sort) 알고리즘 구현해줘. Kahn 알고리즘으로.",
      "action": "```python\nfrom collections import deque\n\ndef topological_sort_kahn(graph):\n    in_degree = {u: 0 for u in graph}  # Initialize in-degree of each vertex\n\n    # Calculate in-degrees\n    for u in graph:\n        for v in graph[u]:\n            in_degree[v] += 1\n\n    # Queue for vertices with no incoming edges\n    queue = deque([u for u in in_degree if in_degree[u] == 0])\n    top_order = []\n\n    while queue:\n        u = queue.popleft()\n        top_order.append(u)\n\n        # Decrease in-degree for neig",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:16:10.766001"
    },
    {
      "id": "48ef8abd5dbb",
      "request": "프림 알고리즘으로 최소 신장 트리 구현해줘.",
      "action": "```python\nimport heapq\n\ndef prim(graph, start):\n    mst = []\n    visited = set()\n    min_heap = [(0, start)]  # (weight, vertex)\n\n    while min_heap:\n        weight, current = heapq.heappop(min_heap)\n\n        if current in visited:\n            continue\n\n        visited.add(current)\n        mst.append((weight, current))\n\n        for neighbor, edge_weight in graph[current].items():\n            if neighbor not in visited:\n                heapq.heappush(min_heap, (edge_weight, neighbor))\n\n    return",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:17:06.161882"
    },
    {
      "id": "84ce06f3e7b1",
      "request": "크루스칼 알고리즘으로 최소 신장 트리 구현해줘. Union-Find 사용.",
      "action": "```python\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [1] * size\n\n    def find(self, p):\n        if self.parent[p] != p:\n            self.parent[p] = self.find(self.parent[p])  # Path compression\n        return self.parent[p]\n\n    def union(self, p, q):\n        rootP = self.find(p)\n        rootQ = self.find(q)\n        if rootP != rootQ:\n            # Union by rank\n            if self.rank[rootP] > self.rank[rootQ]:\n                se",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:19:00.995529"
    },
    {
      "id": "4ed09f3788fa",
      "request": "플로이드-워셜 알고리즘 구현해줘. 모든 쌍 최단 경로.",
      "action": "```python\ndef floyd_warshall(graph):\n    num_vertices = len(graph)\n    dist = [[float('inf')] * num_vertices for _ in range(num_vertices)]\n\n    # 초기 거리 설정\n    for i in range(num_vertices):\n        for j in range(num_vertices):\n            if i == j:\n                dist[i][j] = 0\n            elif graph[i][j] != 0:\n                dist[i][j] = graph[i][j]\n\n    # 플로이드-워셜 알고리즘\n    for k in range(num_vertices):\n        for i in range(num_vertices):\n            for j in range(num_vertices):\n         ",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:21:51.262523"
    },
    {
      "id": "9ab8cc5b5c98",
      "request": "벨만-포드 알고리즘 구현해줘. 음수 가중치 처리 포함.",
      "action": "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = []\n\n    def add_edge(self, u, v, w):\n        self.graph.append((u, v, w))\n\n    def bellman_ford(self, src):\n        distance = [float(\"inf\")] * self.V\n        distance[src] = 0\n\n        for _ in range(self.V - 1):\n            for u, v, w in self.graph:\n                if distance[u] != float(\"inf\") and distance[u] + w < distance[v]:\n                    distance[v] = distance[u] + w\n\n        # ",
      "outcome": "success",
      "success": true,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:22:56.409411"
    },
    {
      "id": "a0c46837c938",
      "request": "0/1 배낭 문제(Knapsack) DP로 구현해줘.",
      "action": "```python\ndef knapsack(weights, values, capacity):\n    n = len(values)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if weights[i - 1] <= w:\n                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])\n            else:\n                dp[i][w] = dp[i - 1][w]\n\n    return dp[n][capacity]\n\n# 예제 사용\nweights = [1, 2, 3]\nvalues = [60, 100, 120]\ncapacity = 5\nprint(knapsack",
      "outcome": "failure",
      "success": false,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-20T00:25:14.497487"
    },
    {
      "id": "862756cc3fd7",
      "request": "최장 증가 부분 수열(LIS) 구현해줘. O(n log n) 이진탐색 방식으로.",
      "action": "```python\ndef length_of_LIS(nums):\n    if not nums:\n        return 0\n\n    from bisect import bisect_left\n    subsequence = []\n\n    for num in nums:\n        pos = bisect_left(subsequence, num)\n        if pos == len(subsequence):\n            subsequence.append(num)\n        else:\n            subsequence[pos] = num\n\n    return len(subsequence)\n\n# Example usage\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(length_of_LIS(nums))  # Output: 4\n```",
      "outcome": "success",
      "success": true,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:26:06.095531"
    },
    {
      "id": "6decad9fa0bf",
      "request": "최장 공통 부분 수열(LCS) DP로 구현해줘.",
      "action": "```python\ndef longest_common_subsequence(X, Y):\n    m = len(X)\n    n = len(Y)\n    \n    # Create a 2D array to store lengths of longest common subsequence\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build L[m + 1][n + 1] in bottom-up fashion\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n    \n    # The length of ",
      "outcome": "success",
      "success": true,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:27:15.169344"
    },
    {
      "id": "1f7bc36ca4be",
      "request": "편집 거리(Edit Distance) 알고리즘 DP로 구현해줘.",
      "action": "```python\ndef edit_distance(s1, s2):\n    len_s1, len_s2 = len(s1), len(s2)\n    dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)]\n\n    for i in range(len_s1 + 1):\n        for j in range(len_s2 + 1):\n            if i == 0:\n                dp[i][j] = j  # If s1 is empty, insert all characters of s2\n            elif j == 0:\n                dp[i][j] = i  # If s2 is empty, remove all characters of s1\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # Characters ",
      "outcome": "failure",
      "success": false,
      "task_type": "algorithm",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-20T00:29:37.433517"
    },
    {
      "id": "dc4348828996",
      "request": "A* 탐색 알고리즘 구현해줘. 휴리스틱 함수 포함.",
      "action": "```python\nimport heapq\n\nclass Node:\n    def __init__(self, position, g, h):\n        self.position = position  # (x, y)\n        self.g = g  # Cost from start to current node\n        self.h = h  # Heuristic cost from current node to goal\n        self.f = g + h  # Total cost\n\n    def __lt__(self, other):\n        return self.f < other.f\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan distance\n\ndef a_star(start, goal, grid):\n    open_list = []\n    closed_list = set()",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-20T00:33:03.549045"
    },
    {
      "id": "2560a9231ad1",
      "request": "이진탐색으로 제곱근 구하는 함수 만들어줘.",
      "action": "```python\ndef binary_search_sqrt(x, epsilon=1e-10):\n    if x < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    if x == 0 or x == 1:\n        return x\n\n    low, high = 0, x\n    while high - low > epsilon:\n        mid = (low + high) / 2\n        if mid * mid < x:\n            low = mid\n        else:\n            high = mid\n\n    return (low + high) / 2\n\n# Example usage\nresult = binary_search_sqrt(25)\nprint(result)  # Output: 5.0\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-20T00:35:11.315885"
    },
    {
      "id": "be1a51c964da",
      "request": "백트래킹으로 N-Queens 문제 구현해줘.",
      "action": "```python\ndef solve_n_queens(n):\n    def backtrack(row, queens, diagonals, anti_diagonals):\n        if row == n:\n            solutions.append(queens[:])\n            return\n        for col in range(n):\n            if col not in queens and (row - col) not in diagonals and (row + col) not in anti_diagonals:\n                queens.append(col)\n                diagonals.add(row - col)\n                anti_diagonals.add(row + col)\n                backtrack(row + 1, queens, diagonals, anti_diagonals)\n  ",
      "outcome": "success",
      "success": true,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:36:45.589086"
    },
    {
      "id": "c3fcde19f866",
      "request": "Subset Sum 재귀 구현",
      "action": "```python\ndef subset_sum(arr, target):\n    if target == 0:\n        return True\n    if len(arr) == 0:\n        return False\n    \n    # Include the last element and check\n    if arr[-1] > target:\n        return subset_sum(arr[:-1], target)\n    \n    # Check both including and excluding the last element\n    return subset_sum(arr[:-1], target) or subset_sum(arr[:-1], target - arr[-1])\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-20T00:40:26.729842"
    },
    {
      "id": "ea5e009417b6",
      "request": "문자열에서 가장 많이 나온 문자 찾기",
      "action": "```python\nfrom collections import Counter\n\ndef most_common_character(s):\n    if not s:\n        return None\n    count = Counter(s)\n    return count.most_common(1)[0][0]\n\n# Example usage\nresult = most_common_character(\"hello world\")\nprint(result)  # Output: 'l'\n```",
      "outcome": "success",
      "success": true,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:41:21.659253"
    },
    {
      "id": "af1bec52bd0b",
      "request": "문자열 뒤집기 3가지 방법으로",
      "action": "def reverse_string_slicing(s):\n    return s[::-1]\n\ndef reverse_string_reversed(s):\n    return ''.join(reversed(s))\n\ndef reverse_string_loop(s):\n    reversed_str = ''\n    for char in s:\n        reversed_str = char + reversed_str\n    return reversed_str\n\n# 테스트\ntest_string = \"Hello, World!\"\nprint(reverse_string_slicing(test_string))\nprint(reverse_string_reversed(test_string))\nprint(reverse_string_loop(test_string))",
      "outcome": "success",
      "success": true,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:42:48.330536"
    },
    {
      "id": "3d81608005f5",
      "request": "데코레이터로 실행 시간 측정 함수",
      "action": "```python\nimport time\n\ndef time_measure(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"Execution time: {end_time - start_time:.6f} seconds\")\n        return result\n    return wrapper\n\n@time_measure\ndef sum_numbers(n):\n    return sum(range(1, n + 1))\n\n# Example usage\nresult = sum_numbers(999999)\n```",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:44:15.120871"
    },
    {
      "id": "fcd1fd568262",
      "request": "싱글톤 패턴 클래스 구현",
      "action": "```python\nclass Singleton:\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if not cls._instance:\n            cls._instance = super(Singleton, cls).__new__(cls)\n        return cls._instance\n\n# Usage example\nsingleton1 = Singleton()\nsingleton2 = Singleton()\n\nprint(singleton1 is singleton2)  # Output: True\n```",
      "outcome": "success",
      "success": true,
      "task_type": "class",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:45:01.924498"
    },
    {
      "id": "69fdb2f06b37",
      "request": "팩토리 패턴 구현",
      "action": "```python\nclass Product:\n    def operation(self):\n        pass\n\nclass ConcreteProductA(Product):\n    def operation(self):\n        return \"Result of ConcreteProductA\"\n\nclass ConcreteProductB(Product):\n    def operation(self):\n        return \"Result of ConcreteProductB\"\n\nclass Creator:\n    def factory_method(self):\n        pass\n\n    def some_operation(self):\n        product = self.factory_method()\n        return product.operation()\n\nclass ConcreteCreatorA(Creator):\n    def factory_method(self):\n  ",
      "outcome": "success",
      "success": true,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:45:48.403520"
    },
    {
      "id": "41cab3d41bb5",
      "request": "옵저버 패턴 구현",
      "action": "```python\nclass Observer:\n    def update(self, message):\n        pass\n\nclass Subject:\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def detach(self, observer):\n        self._observers.remove(observer)\n\n    def notify(self, message):\n        for observer in self._observers:\n            observer.update(message)\n\n# Concrete Observer\nclass ConcreteObserver(Observer):\n",
      "outcome": "success",
      "success": true,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:47:04.208414"
    },
    {
      "id": "9cae3e595223",
      "request": "전략 패턴 Strategy Pattern 구현",
      "action": "```python\nfrom abc import ABC, abstractmethod\n\n# Strategy Interface\nclass SortStrategy(ABC):\n    @abstractmethod\n    def sort(self, data):\n        pass\n\n# Concrete Strategy: Quick Sort\nclass QuickSort(SortStrategy):\n    def sort(self, data):\n        if len(data) <= 1:\n            return data\n        pivot = data[0]\n        left = [x for x in data[1:] if x < pivot]\n        right = [x for x in data[1:] if x >= pivot]\n        return self.sort(left) + [pivot] + self.sort(right)\n\n# Concrete Strategy:",
      "outcome": "success",
      "success": true,
      "task_type": "general",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T00:48:03.363666"
    },
    {
      "id": "992b9dfb0df1",
      "request": "간단한 덧셈 함수를 만들어줘",
      "action": "def add(a, b):\n    return a + b",
      "outcome": "success",
      "success": true,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.815,
      "timestamp": "2026-01-20T15:31:34.125466"
    },
    {
      "id": "9a1456c73871",
      "request": "간단한 곱셈 함수를 만들어줘",
      "action": "```python\ndef multiply(a, b):\n    return a * b\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 0.915,
      "timestamp": "2026-01-20T16:18:28.087963"
    },
    {
      "id": "db6fbf283b17",
      "request": "피보나치 수열 함수를 만들어줘",
      "action": "```python\ndef fibonacci(n):\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```",
      "outcome": "failure",
      "success": false,
      "task_type": "function",
      "emotional_weight": 0.615,
      "importance": 1.0,
      "timestamp": "2026-01-20T16:20:29.202867"
    }
  ],
  "long_term": []
}